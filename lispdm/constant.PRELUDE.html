<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Prelude of LispDM."><title>PRELUDE in lispdm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="lispdm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.1 (7cf61ebde 2024-03-27)" data-channel="1.77.1" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc constant"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../lispdm/index.html">lispdm</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../lispdm/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Constant <a href="index.html">lispdm</a>::<wbr><a class="constant" href="#">PRELUDE</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/lispdm/lib.rs.html#29">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub const PRELUDE: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.77.1/std/primitive.str.html">str</a> = &quot;; equals\n(define (not x) (if x #f #t))\n\n; math\n(define (zero? x) (= 0 x))\n\n(define (positive? x) (&gt; x 0))\n\n(define (negative? x) (&lt; x 0))\n\n; bool\n(define (boolean? x) (if (eq? x #t) #t (eq? x #f)))\n\n; lists and pairs\n(define (list . x) x)\n\n(define (caar x) (car (car x)))\n(define (cadr x) (car (cdr x)))\n(define (cdar x) (cdr (car x)))\n(define (cddr x) (cdr (cdr x)))\n(define (caaar x) (car (car (car x))))\n(define (caadr x) (car (car (cdr x))))\n(define (cadar x) (car (cdr (car x))))\n(define (caddr x) (car (cdr (cdr x))))\n(define (cdaar x) (cdr (car (car x))))\n(define (cdadr x) (cdr (car (cdr x))))\n(define (cddar x) (cdr (cdr (car x))))\n(define (cdddr x) (cdr (cdr (cdr x))))\n(define (caaaar x) (car (car (car (car x)))))\n(define (caaadr x) (car (car (car (cdr x)))))\n(define (caadar x) (car (car (cdr (car x)))))\n(define (caaddr x) (car (car (cdr (cdr x)))))\n(define (cadaar x) (car (cdr (car (car x)))))\n(define (cadadr x) (car (cdr (car (cdr x)))))\n(define (caddar x) (car (cdr (cdr (car x)))))\n(define (cadddr x) (car (cdr (cdr (cdr x)))))\n(define (cdaaar x) (cdr (car (car (car x)))))\n(define (cdaadr x) (cdr (car (car (cdr x)))))\n(define (cdadar x) (cdr (car (cdr (car x)))))\n(define (cdaddr x) (cdr (car (cdr (cdr x)))))\n(define (cddaar x) (cdr (cdr (car (car x)))))\n(define (cddadr x) (cdr (cdr (car (cdr x)))))\n(define (cdddar x) (cdr (cdr (cdr (car x)))))\n(define (cddddr x) (cdr (cdr (cdr (cdr x)))))\n\n(define (null? x) (equal? x \&#39;()))\n\n(define (list? x)\n  (if (pair? x)\n      (list? (cdr x))\n      (null? x)))\n\n(define (length ls)\n  (define (length* ls acc)\n    (if (null? ls)\n        acc\n        (length* (cdr ls) (+ 1 acc))))\n  (length* ls 0))\n\n(define (acc-reverse l acc)\n  (if (null? l)\n      acc\n      (acc-reverse (cdr l) (cons (car l) acc))))\n\n(define (reverse l)\n  (acc-reverse l \&#39;()))\n\n(define (append2 l res)\n  (if (null? l)\n      res\n      (append2 (cdr l) (cons (car l) res))))\n\n(define (append-helper ls res)\n  (if (null? ls)\n      res\n      (append-helper (cdr ls) (append2 (reverse (car ls)) res))))\n\n(define (append . o)\n  (if (null? o)\n      \&#39;()\n      ((lambda (lol)\n         (append-helper (cdr lol) (car lol)))\n       (reverse o))))\n\n(define (list-tail l k)\n  (if (zero? k)\n      l\n      (list-tail (cdr l) (- k 1))))\n\n(define (list-ref l k)\n  (car (list-tail l k)))\n\n(define (mem predicate obj ls)\n  (if (null? ls)\n      #f\n      (if (predicate obj (car ls))\n          ls\n          (mem predicate obj (cdr ls)))))\n\n(define (memq obj ls)\n  (mem eq? obj ls))\n\n(define (memv obj ls)\n  (mem eqv? obj ls))\n\n(define (member obj ls)\n  (mem equal? obj ls))\n\n(define-macro (and . args)\n    (if (null? args)\n      #t\n      (if (null? (cdr args))\n        `(if ,(car args) ,(car args) #f)\n        (let ((tmp (gensym)))\n          `(let ((,tmp ,(car args)))\n             (if ,tmp (and ,@(cdr args)) ,tmp))))))\n\n(define-macro (or . args)\n    (if (null? args)\n      #f\n      (if (null? (cdr args))\n        `(if ,(car args) ,(car args) #f)\n        (let ((tmp (gensym)))\n          `(let ((,tmp ,(car args)))\n             (if ,tmp ,tmp (or ,@(cdr args))))))))\n\n(define (map1 proc lst)\n  (if (null? lst)\n    \&#39;()\n    (cons (proc (car lst))\n          (map1 proc (cdr lst)))))\n\n(define (map proc . lists)\n  (if (null? (car lists))\n    \&#39;()\n    (cons (apply proc (map1 car lists))\n          (apply map proc (map1 cdr lists))))) \n\n(define (string-map proc str)\n  (if (string=? str \&quot;\&quot;)\n      \&quot;\&quot;\n      (string-append (string (proc (string-ref str 0)))\n                     (string-map proc (substring str 1 (string-length str))))))\n\n(define (for-each fn . lists)\n  (apply map fn lists))\n\n(define (string-for-each proc . strings)\n  (define (process-chars chars)\n    (if (null? (car chars))\n        \&#39;()\n        (begin\n          (apply proc (map car chars))\n          (process-chars (map cdr chars)))))\n  (if (null? strings)\n      \&#39;()\n      (let ((char-lists (map string-&gt;list strings)))\n        (process-chars char-lists))))\n\n(define (ass predicate obj ls)\n  (if (null? ls)\n      #f\n      (if (predicate obj (caar ls))\n          (car ls)\n          (ass predicate obj (cdr ls)))))\n\n(define (assq obj ls)\n  (ass eq? obj ls))\n\n(define (assv obj ls)\n  (ass eqv? obj ls))\n\n(define (assoc obj ls)\n  (ass equal? obj ls))\n\n; chars\n(define (char=? . c)\n  (apply = (map char-&gt;integer c)))\n(define (char&lt;? . c)\n  (apply &lt; (map char-&gt;integer c)))\n(define (char&gt;? . c)\n  (apply &gt; (map char-&gt;integer c)))\n(define (char&lt;=? . c)\n  (apply &lt;= (map char-&gt;integer c)))\n(define (char&gt;=? . c)\n  (apply &gt;= (map char-&gt;integer c)))\n\n; strings\n(define (string-copy string)\n  (substring string 0 (string-length string)))\n\n(define (list-&gt;string lst)\n  (apply string lst))\n\n; special forms\n(define #:gensym-counter 0)\n\n(define (gensym)\n  (set! #:gensym-counter (+ #:gensym-counter 1))\n  (string-&gt;symbol (string-append \&quot;#:gensym-\&quot; (number-&gt;string #:gensym-counter))))\n\n(define-macro (when test . body) `(if ,test (begin ,@body)))\n\n(define-macro (unless test . body) `(if (not ,test) (begin ,@body)))\n\n(define-macro (let* bindings . body)\n  (if (null? bindings)\n      `(let ,bindings ,@body)\n      `(let ,(list (car bindings)) (let* ,(cdr bindings) ,@body))))\n\n(define-macro (letrec* bindings . body) `(letrec ,bindings ,@body))\n\n(define-macro (case key . case-clauses)\n  (let ((tmp (gensym)))\n    `(let ((,tmp ,key))\n       (cond ,@(map (lambda (case-clause)\n                      (if (eq? (car case-clause) \&#39;else)\n                        (if (eq? (cadr case-clause) \&#39;=&gt;)\n                          `(,tmp =&gt; ,(caddr case-clause))\n                          `(,tmp ,@(cdr case-clause)))\n                        `((if (memv ,tmp \&#39;,(car case-clause)) ,tmp #f) ,@(cdr case-clause))))\n                    case-clauses)))))\n\n(define (n-el-list? x n)\n  (and (list? x) (= (length x) n)))\n\n(define (1-el-list? x) (n-el-list? x 1))\n(define (2-el-list? x) (n-el-list? x 2))\n\n(define (unquoted? x)\n  (and (2-el-list? x) (eq? (car x) \&#39;unquote)))\n\n;; (match &lt;expr&gt; (&lt;pattern&gt; &lt;expression&gt; ...) ...)\n;; a simple pattern matcher, that matches &lt;expr&gt; against &lt;pattern&gt;\&#39;s\n(define-macro (match expr . match-clauses)\n  (let ((tmp (gensym)))\n    `(let ((,tmp ,expr))\n       (cond ,@(map (lambda (match-clause)\n                      (let ((pat (car match-clause)))\n                        (cond\n                          ;; ,_ - match anything\n                          ((equal? pat \&#39;,_)\n                           `(#t ,@(cdr match-clause)))\n                          ;; ,&lt;symbol&gt; - match anything and binds to &lt;symbol&gt;\n                          ((and (unquoted? pat) (symbol? (cadr pat)))\n                           `(#t (let ((,(cadr pat) ,tmp)) ,@(cdr match-clause))))\n                          ;; ,(&lt;type&gt; _) - match anything of &lt;type&gt;\n                          ;; ,(&lt;type&gt; &lt;symbol&gt;) - match anything of &lt;type&gt; and bind it to &lt;symbol&gt;\n                          ((and\n                             (unquoted? pat)\n                             (2-el-list? (cadr pat))\n                             (member (caadr pat) \&#39;(number string char boolean pair procedure symbol list)))\n                           (if (equal? (cadadr pat) \&#39;_)\n                             `((,(string-&gt;symbol (string-append (symbol-&gt;string (caadr pat)) \&quot;?\&quot;)) ,tmp)\n                               ,@(cdr match-clause))\n                             `((,(string-&gt;symbol (string-append (symbol-&gt;string (caadr pat)) \&quot;?\&quot;)) ,tmp)\n                               (let ((,(cadadr pat) ,tmp)) ,@(cdr match-clause)))))\n                          ;; &lt;literal&gt; - match &lt;literal&gt;\n                          ((or\n                             (boolean? pat)\n                             (char? pat)\n                             (number? pat)\n                             (string? pat))\n                           `((equal? ,tmp ,pat) ,@(cdr match-clause)))\n                          ((or\n                             (symbol? pat)\n                             (list? pat))\n                           `((equal? ,tmp \&#39;,pat) ,@(cdr match-clause)))\n                          ;; unknown pattern\n                          (else `(error \&quot;unknown pattern\&quot; \&#39;,pat)))))\n                    match-clauses)\n             ;; no match - error\n             (else (error \&quot;no match clause was selected\&quot;))))))\n\n; lazy evaluation\n(define make-promise\n  (lambda (proc)\n    (let ((result-ready? #f)\n          (result #f))\n      (lambda ()\n        (if result-ready?\n            result\n            (let ((x (proc)))\n              (if result-ready?\n                  result\n                  (begin (set! result-ready? #t)\n                          (set! result x)\n                          result))))))))\n\n(define-macro (delay expression) `(make-promise (lambda () ,expression)))\n\n(define force\n  (lambda (object)\n    (object)))\n\n(define lazy-car car)\n    \n(define (lazy-cdr ls)\n  (force (cdr ls)))\n\n(define-macro (lazy-cons a b)\n  `(cons ,a (delay ,b)))\n\n(define (lazy-map fn . lss)\n  (if (memq \&#39;() lss)\n   \&#39;()\n    (lazy-cons (apply fn (map lazy-car lss))\n      (apply lazy-map fn (map lazy-cdr lss)))))\n    \n(define (lazy-filter pred ls)\n  (if (null? ls)\n    \&#39;()\n    (let ((obj (lazy-car ls)))\n      (if (pred obj)\n        (lazy-cons obj (lazy-filter pred (lazy-cdr ls)))\n        (lazy-filter pred (lazy-cdr ls))))))\n\n(define (lazy-ref ls n)\n  (if (= n 0)\n    (lazy-car ls)\n    (lazy-ref (lazy-cdr ls) (- n 1))))\n\n(define (head ls n)\n  (if (= n 0)\n    \&#39;()\n    (cons (lazy-car ls) (head (lazy-cdr ls) (- n 1)))))\n\n; math        \n(define (even? x)\n  (and (integer? x)\n       (zero? (modulo x 2))))\n\n(define (odd? x)\n  (and (integer? x)\n       (not (zero? (modulo x 2)))))\n\n; ports\n(define (eof-object) \&#39;#!eof)\n\n(define (eof-object? obj)\n  (equal? obj (eof-object)))\n&quot;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Prelude of LispDM.</p>
<p>Contains implementation of some special forms and standard procedures.</p>
<p>Loaded by default when creating a new instance of <a href="struct.Engine.html" title="struct lispdm::Engine"><code>Engine</code></a>.</p>
</div></details></section></div></main></body></html>