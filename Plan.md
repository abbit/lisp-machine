# Lisp-машина

## Авторы

- Даниил Клюс 23223
- Михаил Копылов 23223

## Цель

Разработать интерпретатор языка Scheme (части стандарта R7RS) на языке Rust.

## Базовые требования

- [x] Определение функции
- [x] Определение статического лексического контекста
- [x] Рекурсия (в том числе оптимизированная хвостовая рекурсия)
- [x] Ветвление, логические связки с отложенным порядком исполнения
- [x] Присваивание для ранее определенных символов
- [ ] Макросы (как defmacro из Clojure)
- [ ] Ввод-вывод (консольный и файловый)
- [ ] Возможность добавления встроенных функций на Rust

Поведение языка должно соответствовать стандарту R7RS.

Реализация интерпретатора на языке Rust должна быть выполнена в виде библиотеки, которая может быть использована в других проектах.

Реализация на Rust должна содержать минимальный набор встроенных функций, необходимых для написания программ на языке Scheme. Все остальные необходимые элементы языка должны быть выражены в этом минимальном базисе.

## Реализация на Rust должна содержать:

### Базовые типы данных

- [x] `boolean` (#t, #f, #true, #false)
- [x] `number` (integer, float)
- [x] `string`
- [x] `symbol`
- [x] `list`
- [ ] `pair` (`improper list`)
- [x] `char`
- [ ] `port`
- [x] `procedure`

### Функции для работы с базовыми типами данных

- [x] арифметические операции (`+`, `-`, `*`, `/`, ...)
- [x] операции сравнения (`=`, `>`, `<`, `>=`, `<=`)
- [ ] операции над списками (`cons`, `car`, `cdr`, `list`, `list?`, `null?`, `length`, ...)
- [ ] операции над строками (`concat`, `substring`, `string-length`, ...)
- ...

### Специальные формы

- [x] `define`
- [x] `set!`
- [x] `lambda`
- [x] `apply`
- [x] `eval`
- [x] `quote`
- [x] `quasiquote`
- [x] `unquote`
- [x] `unquote-splicing`
- [x] `if`
- [x] `read`
- [ ] `write`
- [ ] `include`
- [ ] `define-macro`

## Возможности, которые должны быть реализованы на языке Scheme

- [ ] `let`
- [ ] `and`
- [ ] `or`
- [ ] `cond`
- [ ] `load`
- ...

## Дополнительные требования:

- [ ] Реализация pattern matching
- [ ] Реализация ленивых вычислений, отложенного порядка вычислений для вызовов функций
