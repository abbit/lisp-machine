var searchIndex = new Map(JSON.parse('[\
["lispdm",{"doc":"LispDM is a Scheme interpreter. Currently, it supports …","t":"PGPPPFFPPPPGIPKIPPGFPPPPSPPPIGIGPPPPPPPNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNQNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN","n":["Any","Arity","AtLeast","Boolean","Char","Engine","EnvRef","Err","Err","EvalError","Exact","Expr","Exprs","Float","FromExpr","FromExprResult","InputPort","Integer","LispDMError","List","List","Ok","Ok","OutputPort","PRELUDE","ParseError","Procedure","Procedure","ProcedureFn","ProcedureKind","ProcedureResult","ProcedureReturn","Range","SpecialForm","String","Symbol","TailCall","Value","Void","add","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","but_last","car","cdr","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","copy","current_input_port","current_output_port","cwd","default","default","env","eq","eq","eq","eq","eq","eval","exprs","extend","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from","from_expr","from_expr","from_expr","get","get_expr","has","has_macro","into","into","into","into","into","into","into","into","into","into_exprs","into_iter","into_iter","is_boolean","is_char","is_dotted","is_dotted_list","is_empty","is_empty_list","is_float","is_input_port","is_integer","is_list","is_output_port","is_procedure","is_proper","is_proper_list","is_root","is_specific_symbol","is_string","is_symbol","is_truthy","is_void","iter","kind","kind","last","len","new","new_dotted","new_dotted_list","new_empty","new_empty_list","new_proper","new_proper_list","new_string","new_symbol","new_without_prelude","pop_front","register_fn","set","set_current_input_port","set_current_output_port","set_cwd","split_first","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","to_string","to_string","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id"],"q":[[0,"lispdm"],[209,"alloc::string"],[210,"core::convert"],[211,"core::iter::traits::iterator"],[212,"core::option"],[213,"core::cell"],[214,"alloc::rc"],[215,"std::path"],[216,"core::result"],[217,"core::fmt"],[218,"core::fmt"],[219,"alloc::collections::vec_deque"],[220,"alloc::string"]],"d":["Any number of arguments.","Represents the arity of a procedure.","At least this many arguments.","Boolean","Character","Provides the main functionality of LispDM.","Reference to the environment.","Contains the error value","Contains the error value","Error occurred while evaluating expressions.","Exact number of arguments.","Represents all possible values in interpreter.","A list of <code>Expr</code>s. Also can be created with <code>exprs!</code> macro.","Real number","The exit point for turning <code>Expr</code> into Rust types.","Represents result of conversion from <code>Expr</code> to another type","Input port","Integer number","Error type that represents all possible errors in LispDM.","List of expressions.","An immutable list of expressions.","Contains the success value","Contains the success value","Output port","Prelude of LispDM.","Error occurred while parsing source code.","Procedure","A normal procedure. Arguments <em>are</em> evaluated before the …","The type of a procedure function.","Represents the kind of a procedure.","The result of a procedure call.","The return value of a procedure. Used to determine whether …","From min to max arguments.","A special form. Arguments <em>are not</em> evaluated before the …","A reference to mutable string.","Symbol","Perform a tail call of <code>Expr</code> in <code>EnvRef</code>.","Return <code>Expr</code>.","Unspecified value","Adds a new binding to the environment. If the binding …","","","","","","","","","","","","","","","","","Returns iterator over all elements except the last.","Returns the first element of the list or <code>None</code> if list is …","Returns iterator over the cdr of the list.","","","","","","","","","","","Creates a reference to the deep copy of underlying …","Returns the current input port of the environment.","Returns the current output port of the environment.","Returns the current working directory of the environment.","","","Returns reference to the root environment.","","","","","","Evaluates the given source code and returns the result. …","A helper macro to construct <code>Exprs</code> from given expressions","Creates a reference to a new environment that has this …","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Tries to convert <code>Expr</code> into <code>Self</code>. Returns …","","","<code>get_expr</code> with a type conversion.","Returns the expression bound to <code>name</code>. If the no expression …","Checks if <code>self</code> contains a binding with <code>name</code>.","Checks if <code>self</code> contains a macro with <code>name</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Tries to convert <code>self</code> into <code>T</code>, which is a type that …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Converts list into <code>Exprs</code>.","","","Checks if <code>self</code> is a <code>Expr::Boolean</code>","Checks if <code>self</code> is a <code>Expr::Char</code>","Checks if list is dotted.","Checks if <code>self</code> represents a dotted list This means that …","Checks if list is empty.","Checks if <code>self</code> represents an empty list <code>&#39;()</code>","Checks if <code>self</code> is a <code>Expr::Float</code>","Checks if <code>self</code> is a <code>Expr::InputPort</code>","Checks if <code>self</code> is a <code>Expr::Integer</code>","checks if <code>self</code> is a <code>Expr::List</code>","Checks if <code>self</code> is a <code>Expr::OutputPort</code>","Checks if <code>self</code> is a <code>Expr::Procedure</code>","Checks if list is proper.","Checks if <code>self</code> represents a proper list","Checks if <code>self</code> is the root environment.","Checks if <code>self</code> is a <code>Expr::Symbol</code> with given <code>name</code>","Checks if <code>self</code> is a <code>Expr::String</code>","Checks if <code>self</code> is a <code>Expr::Symbol</code>","Returns true if <code>self</code> represents a true value","Checks if <code>self</code> is a <code>Expr::Void</code>","Returns iterator over all elements of the list.","Returns string representation of the type of <code>self</code>","Returns the kind of the list.","Returns the last element of the list or <code>None</code> if list is …","Returns the length of the list.","Creates a new list.","Creates a new dotted list.","Creates new dotted list like <code>&#39;(1 2 . 3)</code> from <code>Exprs</code>","Creates a new empty list.","Creates new empty list <code>&#39;()</code>","Creates a new proper list.","Creates new proper list like <code>&#39;(1 2 3)</code> from <code>Exprs</code>","Creates new <code>Expr::String</code> from any type that implements …","Creates new <code>Expr::Symbol</code> from any type that implements …","Creates a new instance of <code>Engine</code> without loading the …","Removes the first element of the list and returns it. …","Registers a new procedure in the root environment. Can be …","Sets new value to an existing binding. Returns an <code>Err</code> if …","Sets the current input port of the environment.","Sets the current output port of the environment.","Sets the current working directory of the environment.","Splits list into first element and the rest of the list. …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[11,0,11,4,4,0,0,18,35,19,11,0,0,4,0,0,4,4,0,0,4,18,35,4,0,19,4,10,0,0,0,0,11,10,4,4,36,36,4,1,36,15,1,4,6,10,11,19,36,15,1,4,6,10,11,19,6,6,6,1,4,6,10,11,1,4,6,10,11,1,1,1,1,15,1,15,1,4,6,10,11,15,0,1,1,4,4,6,6,10,11,11,19,19,24,36,15,1,4,4,4,4,4,4,4,4,4,4,4,4,4,6,10,11,19,21,4,6,1,1,1,1,36,15,1,4,4,6,10,11,19,6,6,6,4,4,6,4,6,4,4,4,4,4,4,4,6,4,1,4,4,4,4,4,6,4,6,6,6,6,6,4,6,4,6,4,4,4,15,6,15,1,1,1,1,6,1,4,6,10,11,4,6,11,19,36,15,1,4,6,10,11,19,36,15,1,4,6,10,11,19,36,15,1,4,6,10,11,19],"f":"```````````````````````````````````````{{bdc}f{{j{h}}}}{ce{}{}}000000000000000{l{{`{{A`{}{{n{h}}}}}}}}{l{{Ab{h}}}}1{bb}{hh}{ll}{AdAd}{AfAf}{{ce}f{}{}}00005{b{{Aj{{Ah{`}}}}}}0{bAl}{{}An}{{}b}{Anb}{{bb}B`}{{hh}B`}{{ll}B`}{{AdAd}B`}{{AfAf}B`}{{AnBb}{{Bh{{Bd{c}}Bf}}}Bj}`{bb}{{bBl}Bn}{{hBl}Bn}0{{lBl}Bn}0{{AdBl}Bn}{{AfBl}Bn}0{{BfBl}Bn}0{lC`}{cc{}}000{Cbh}{{{Aj{{Ah{`}}}}}h}{{{Cd{ce}}}h{{j{h}}}{{j{h}}}}{{{Cf{c}}}h{{j{h}}}}{Chh}{Cjh}4{lh}{B`h}{dh}{Bbh}{{{Cl{c}}}h{{j{h}}}};;;;{h{{Bd{Bj}}}}{h{{Bd{h}}}}{h{{Bd{l}}}}{{bBb}{{Ab{{Bd{c}}}}}Bj}{{bBb}{{Ab{h}}}}{{bBb}B`}0{ce{}{}}000{h{{Bd{c}}}Bj}1111{lC`}{lc{}}0{hB`}0{lB`}10111111101{bB`}{{hBb}B`}3333{l{{`{{A`{}{{n{h}}}}}}}}{hBb}`{l{{Ab{h}}}}{lCn}{{C`{Ab{h}}}l}{{C`h}l}{C`h}{{}l}{{}h}{C`l}3{ch{{j{d}}}}0{{}An}9{{AncAdAfD`}fDb}{{bdc}{{Bh{fd}}}{{j{h}}}}{{b{Aj{{Ah{`}}}}}f}0{{bAl}f}{l{{Bh{{Cd{hl}}l}}}}{ce{}{}}0000{cd{}}000{c{{Bh{e}}}{}{}}000000000000000{cDd{}}0000000","c":[],"p":[[5,"EnvRef",0],[5,"String",209],[1,"unit"],[6,"Expr",0],[10,"Into",210],[5,"List",0],[17,"Item"],[10,"Iterator",211],[6,"Option",212],[6,"ProcedureKind",0],[6,"Arity",0],[5,"RefCell",213],[5,"Rc",214],[5,"PathBuf",215],[5,"Engine",0],[1,"bool"],[1,"str"],[8,"FromExprResult",0],[6,"LispDMError",0],[6,"Result",216],[10,"FromExpr",0],[5,"Formatter",217],[8,"Result",217],[8,"Exprs",0],[1,"i64"],[1,"tuple"],[5,"Vec",218],[1,"char"],[1,"f64"],[5,"VecDeque",219],[1,"usize"],[8,"ProcedureFn",0],[10,"ToString",209],[5,"TypeId",220],[8,"ProcedureResult",0],[6,"ProcedureReturn",0]],"b":[[85,"impl-Debug-for-Expr"],[86,"impl-Display-for-Expr"],[87,"impl-Display-for-List"],[88,"impl-Debug-for-List"],[90,"impl-Display-for-Arity"],[91,"impl-Debug-for-Arity"],[92,"impl-Debug-for-LispDMError"],[93,"impl-Display-for-LispDMError"],[99,"impl-From%3Ci64%3E-for-Expr"],[100,"impl-From%3CRc%3CRefCell%3Cdyn+OutputPortSuperTrait%3E%3E%3E-for-Expr"],[101,"impl-From%3C(A,+B)%3E-for-Expr"],[102,"impl-From%3CVec%3CT%3E%3E-for-Expr"],[103,"impl-From%3Cchar%3E-for-Expr"],[104,"impl-From%3Cf64%3E-for-Expr"],[105,"impl-From%3CRc%3CRefCell%3Cdyn+InputPortSuperTrait%3E%3E%3E-for-Expr"],[106,"impl-From%3CList%3E-for-Expr"],[107,"impl-From%3Cbool%3E-for-Expr"],[108,"impl-From%3CString%3E-for-Expr"],[109,"impl-From%3C%26str%3E-for-Expr"],[110,"impl-From%3CVecDeque%3CT%3E%3E-for-Expr"],[132,"impl-IntoIterator-for-%26List"],[133,"impl-IntoIterator-for-List"]]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
